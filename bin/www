#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
var debug = require('debug')('nodechat:server')
var http = require('http')


/**
 * Get port from environment and store in Express.
*/

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
* Create HTTP server.
*/

var server = http.createServer(app)

var firebase = require('firebase')
var db = firebase.database()

/**
* Set up a socket.io instance
*/
var io = require('socket.io')(server)

/**
* Listen on provided port, on all network interfaces.
*/
server.listen(port)
server.on('error', onError)
server.on('listening', onListening)


/**
 * Returns a timestamp string
 */
function createTimestamp() {
  var d = new Date()
  var h = d.getHours()
  var m = d.getMinutes()
  if (h < 10) h = '0' + h
  if (m < 10) m = '0' + m
  return h + ':' + m
}

/**
 * Handle socket.io stuff
 *
 * This handles all the logic regarding
 * user interaction with the websocket
 * including connection, sending messages etc.
 */
io.on('connection', (socket) => {

  // By default join the global chatroom
  socket.join('global')
  console.log('Client joined chatroom "Global"')

  /**
   * Client can join different channels using the 
   * subscribe method on the client side. It triggers
   * the socket.join -method on the server side.
   */

  socket.on('unsubscribe', (room) => {
    socket.leave(room)
  })

  socket.on('subscribe', (room) => {
    socket.join(room)
  })

  /**
   * Handle sent messages. 
   *
   * If the message begins with a command,
   * handle it accordingly. (etc display help
   * or change nickname)
   *
   * In the event of 'chatmessage', 
   * emit that message to everyone.
   *
   * Client only sends the content of the
   * message. When the message is emitted
   * back to the client, the user data is
   * sent as well to identify chatters.
   */
  socket.on('chatmessage', (msg) => {
    console.log(msg.nick + '@' + msg.room + ': ' + msg.message)
    /* eslint-disable */
    var data = {
      "message": msg.message,
      "nickname": msg.nick,
      "sender": msg.sender,
      "timestamp": createTimestamp(),
      "room": msg.room
    }
    /* eslint-enable */

    // Split the message string into an array
    var cmd = data.message.trim().split(' ')

    /**
     * In case the user sends a command (etc
     * /help or /nick), the response is emitted
     * only back to them. In any other case, everyone
     * gets the message
     */
    /* eslint-disable*/
    switch (cmd[0]) {
      case '/help':
        data.message = 'Type /nick <nickname> to change nick'
        data.sender = 'Admin'
        socket.emit('chatmessage', data)
        break
      case '/nick':
        db.ref('users').child(data.sender.uid).update({
          'nickname': cmd[1]
        })
        data.message = 'Changed nickname to ' + cmd[1]
        data.nickname = 'Admin'
        socket.emit('chatmessage', data)
        break
      default:
        io.to(data.room).emit('chatmessage', data)
    }
  })
  /* eslint-enable */

  /**
   * Handle disconnection
   */
  socket.on('disconnect', () => {
    console.log('Client disconnected')
  })
})


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10)

  if (isNaN(port)) {
    // named pipe
    return val
  }

  if (port >= 0) {
    // port number
    return port
  }

  return false
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port

  // handle specific listen errors with friendly messages
  switch (error.code) {
  case 'EACCES':
    console.error(bind + ' requires elevated privileges')
    process.exit(1)
    break
  case 'EADDRINUSE':
    console.error(bind + ' is already in use')
    process.exit(1)
    break
  default:
    throw error
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address()
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port
  debug('Listening on ' + bind)
}
