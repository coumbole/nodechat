#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
var debug = require('debug')('nodechat:server')
var http = require('http')


/**
 * Get port from environment and store in Express.
*/

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
* Create HTTP server.
*/

var server = http.createServer(app)

var firebase = require('firebase')
/**
* Set up a socket.io instance
*/
var io = require('socket.io')(server)

/**
* Listen on provided port, on all network interfaces.
*/
server.listen(port)
server.on('error', onError)
server.on('listening', onListening)

io.on('connection', (socket) => {
	if (firebase.auth().currentUser) {
		console.log(firebase.auth().currentUser.email + ' connected')
	} else {
		console.log('Anon connected')
	}


	/**
	 * Handle loggin in
	 * TODO:
	 *	- When a user logs in, fetch old
	 *		conversations
	 */
	/*
	socket.emit('chatmessage', { 
		message: 'Welcome to the chat!', 
		sender: 'admin'
	})
	*/

	/**
	 * Handle sent messages. 
	 * In the event of 'chatmessage', 
	 * emit that message to everyone.
	 *
	 * Client only sends the content of the
	 * message. When the message is emitted
	 * back to the client, the user data is
	 * sent as well to identify chatters.
	 */
	socket.on('chatmessage', (msg) => {
		var user = firebase.auth().currentUser
		console.log(user.email + ': ' + msg.message)
		/* eslint-disable */
		var data = {
			"message": msg.message,
			"sender": user
		}
		/* eslint-enable */
		io.emit('chatmessage', data)
	})

	/**
	 * Handle disconnection
	 * TODO: 
	 *	- Save sent messages in json format
	 *		to firebase
	 */
	socket.on('disconnect', () => {
		console.log('Client disconnected')
	})
})


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10)

	if (isNaN(port)) {
		// named pipe
		return val
	}

	if (port >= 0) {
		// port number
		return port
	}

	return false
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error
	}

	var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port

  // handle specific listen errors with friendly messages
	switch (error.code) {
	case 'EACCES':
		console.error(bind + ' requires elevated privileges')
		process.exit(1)
		break
	case 'EADDRINUSE':
		console.error(bind + ' is already in use')
		process.exit(1)
		break
	default:
		throw error
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = server.address()
	var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port
	debug('Listening on ' + bind)
}
