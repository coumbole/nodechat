#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
var debug = require('debug')('nodechat:server')
var http = require('http')


/**
 * Get port from environment and store in Express.
*/

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
* Create HTTP server.
*/

var server = http.createServer(app)

var firebase = require('firebase')
var db = firebase.database()

/**
* Set up a socket.io instance
*/
var io = require('socket.io')(server)

/**
* Listen on provided port, on all network interfaces.
*/
server.listen(port)
server.on('error', onError)
server.on('listening', onListening)


/**
 * Returns a timestamp string
 */
function createTimestamp() {
  var d = new Date()
  var h = d.getHours()
  var m = d.getMinutes()
  if (h < 10) h = '0' + h
  if (m < 10) m = '0' + m
  return h + ':' + m
}

/**
 * Handle socket.io stuff
 *
 * This handles all the logic regarding
 * user interaction with the websocket
 * including connection, sending messages etc.
 */
io.on('connection', (socket) => {

  // Make the user variable accessible 
  var user = firebase.auth().currentUser

  var nick = null

  /**
   * Fetch a nickname for the user. If it doesn't
   * exist, create an entry for it in the database
   * using the email address.
   */
  firebase.auth().onAuthStateChanged( (usr) => {
    if (usr) {
      var userRef = db.ref('users/')
      userRef.child(usr.uid).once('value', (snapshot) => {
        var exists = (snapshot.val() !== null)
        if (exists) {
          console.log('User node exist')
          console.log('Setting nick variable')
          db.ref('users/' + usr.uid).once('value', (snapshot) => {
            snapshot.forEach( (child) => {
              console.log("child.val(): " + child.val())
              nick = child.val()
            })
          })
        } else {
          userRef.child(usr.uid).set({
            'nickname': usr.email.slice(0, 8)
          })
          console.log('Set nickname to default usign email')
        }
      })
    } else {
      console.log("No user logged in, perhaps logged out")
    }
  })


  /**
   * For debugging purposes, print to console
   * if the connected user is authenticated
   */
  if (user) {
    console.log(user.email + ' connected')
  } else {
    console.log('Anon connected')
	}

	/**
	 * Handle sent messages. 
   *
   * If the message begins with a command,
   * handle it accordingly. (etc display help
   * or change nickname)
   *
	 * In the event of 'chatmessage', 
	 * emit that message to everyone.
	 *
	 * Client only sends the content of the
	 * message. When the message is emitted
	 * back to the client, the user data is
	 * sent as well to identify chatters.
	 */
	socket.on('chatmessage', (msg) => {
		console.log(nick+ ': ' + msg.message)
		/* eslint-disable */
		var data = {
			"message": msg.message,
			"sender": nick,
      "timestamp": createTimestamp()
		}
		/* eslint-enable */

    // Split the message string into an array
    var cmd = data.message.trim().split(' ')

    // In case the message starts with a command, handle that
    // Otherwise emit the message
    switch (cmd[0]) {
      case '/help':
        data.message = 'Type /nick <nickname> to change nick'
        data.sender = 'Admin'
        io.emit('chatmessage', data)
        break
      case '/nick':
        db.ref('users').child(user.uid).update({
          'nickname': cmd[1]
        })
        nick = cmd[1]
        data.message = 'Changed nickname to ' + cmd[1]
        data.sender = 'Admin'
        io.emit('chatmessage', data)
        break
      default:
        io.emit('chatmessage', data)
    }
	})

	/**
	 * Handle disconnection
	 */
	socket.on('disconnect', () => {
		console.log('Client disconnected')
	})
})


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10)

	if (isNaN(port)) {
		// named pipe
		return val
	}

	if (port >= 0) {
		// port number
		return port
	}

	return false
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error
	}

	var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port

  // handle specific listen errors with friendly messages
	switch (error.code) {
	case 'EACCES':
		console.error(bind + ' requires elevated privileges')
		process.exit(1)
		break
	case 'EADDRINUSE':
		console.error(bind + ' is already in use')
		process.exit(1)
		break
	default:
		throw error
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
	var addr = server.address()
	var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port
	debug('Listening on ' + bind)
}
